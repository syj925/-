# ğŸ·ï¸ æ ¡å›­å¢™æ ‡ç­¾ç³»ç»Ÿå®ç°æ–¹æ¡ˆ

> **é¡¹ç›®ç›®æ ‡**ï¼šåŸºäºç°æœ‰æ–°ç‰ˆæ¶æ„å®ç°å®Œæ•´çš„ç”¨æˆ·æ ‡ç­¾/å¾½ç« ç³»ç»Ÿ
> 
> **åˆ›å»ºæ—¶é—´**ï¼š2025-01-27
> 
> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0

## ğŸ“Š é¡¹ç›®ç°çŠ¶åˆ†æ

### ğŸ” å·²æœ‰åŸºç¡€
- âœ… **ç®¡ç†åå°ç•Œé¢**ï¼šå·²å­˜åœ¨å®Œæ•´çš„æ ‡ç­¾ç®¡ç†é¡µé¢ (`admin/src/views/badge/BadgeManagement.vue`)
- âœ… **å‰ç«¯å±•ç¤ºæ¡†æ¶**ï¼šä¸ªäººä¸»é¡µUIå·²æ”¯æŒæˆå°±å¾½ç« å±•ç¤º
- âœ… **åˆç‰ˆæ•°æ®æ¨¡å‹**ï¼šserveråˆç‰ˆå·²æœ‰å®Œæ•´çš„Badgeå’ŒUserBadgeæ¨¡å‹è®¾è®¡
- âŒ **æ–°ç‰ˆåç«¯ç¼ºå¤±**ï¼šå½“å‰serverç‰ˆæœ¬å®Œå…¨ç¼ºå°‘æ ‡ç­¾ç³»ç»Ÿåç«¯å®ç°

### ğŸ¯ ç›®æ ‡åŠŸèƒ½
- **ç”¨æˆ·å¾½ç« ç³»ç»Ÿ**ï¼šæ ¡å›­è¾¾äººã€ä¼˜è´¨åšä¸»ã€æ´»è·ƒç”¨æˆ·ç­‰æˆå°±å¾½ç« 
- **å…´è¶£æ ‡ç­¾ç³»ç»Ÿ**ï¼šç”¨æˆ·å¯é€‰æ‹©çš„å…´è¶£æ ‡ç­¾
- **æ™ºèƒ½æ¨è**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºçš„æ ‡ç­¾æ¨è
- **ç®¡ç†åŠŸèƒ½**ï¼šç®¡ç†å‘˜å¯ç®¡ç†å¾½ç« å®šä¹‰å’Œç”¨æˆ·æˆäºˆ

### ğŸ“‹ åŠŸèƒ½æ¨¡å—å¯¹æ¯”

| åŠŸèƒ½æ¨¡å— | serveråˆç‰ˆ | serverå½“å‰ç‰ˆæœ¬ | ç¼ºå¤±ç¨‹åº¦ | è¿ç§»ä¼˜å…ˆçº§ |
|---------|-----------|---------------|---------|-----------|
| **ç”¨æˆ·æ ‡ç­¾ç³»ç»Ÿ** | âœ… å®Œæ•´ | âŒ æ—  | ğŸ”´ å®Œå…¨ç¼ºå¤± | ä¸­ç­‰ |
| **å¾½ç« ç®¡ç†åå°** | âœ… å®Œæ•´ | ğŸŸ¡ UIå·²å®Œæˆ | ğŸŸ¡ ç¼ºå°‘åç«¯API | é«˜ |
| **å‰ç«¯å¾½ç« å±•ç¤º** | âœ… å®Œæ•´ | ğŸŸ¡ æ¡†æ¶å·²å®Œæˆ | ğŸŸ¡ ç¼ºå°‘æ•°æ®æ¥å£ | é«˜ |

---

## ğŸ—ï¸ æ–°ç‰ˆæ¶æ„å®ç°æ–¹æ¡ˆ

### 1. æ•°æ®æ¨¡å‹å±‚è®¾è®¡

#### 1.1 Badgeæ¨¡å‹ (`server/src/models/badge.model.js`)

```javascript
const { v4: uuidv4 } = require('uuid');

module.exports = (sequelize, DataTypes) => {
  const Badge = sequelize.define('Badge', {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: () => uuidv4(),
      allowNull: false
    },
    name: {
      type: DataTypes.STRING(50),
      allowNull: false,
      unique: true,
      validate: {
        len: [2, 50],
        notEmpty: true
      }
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    color: {
      type: DataTypes.STRING(20),
      allowNull: false,
      defaultValue: '#4A90E2',
      validate: {
        is: /^#[0-9A-Fa-f]{6}$/
      }
    },
    icon: {
      type: DataTypes.STRING(100),
      allowNull: true,
      comment: 'å¾½ç« å›¾æ ‡åç§°æˆ–è·¯å¾„'
    },
    type: {
      type: DataTypes.ENUM('achievement', 'interest', 'system'),
      allowNull: false,
      defaultValue: 'achievement',
      comment: 'achievement:æˆå°±å¾½ç« , interest:å…´è¶£æ ‡ç­¾, system:ç³»ç»Ÿæ ‡ç­¾'
    },
    rarity: {
      type: DataTypes.ENUM('common', 'rare', 'epic', 'legendary'),
      allowNull: false,
      defaultValue: 'common',
      comment: 'ç¨€æœ‰åº¦ï¼šæ™®é€šã€ç¨€æœ‰ã€å²è¯—ã€ä¼ å¥‡'
    },
    auto_grant: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
      comment: 'æ˜¯å¦è‡ªåŠ¨æˆäºˆ'
    },
    grant_condition: {
      type: DataTypes.JSON,
      allowNull: true,
      comment: 'è‡ªåŠ¨æˆäºˆæ¡ä»¶é…ç½®'
    },
    sort_order: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 0
    },
    status: {
      type: DataTypes.ENUM('active', 'inactive'),
      allowNull: false,
      defaultValue: 'active'
    }
  }, {
    tableName: 'badges',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      { fields: ['name'] },
      { fields: ['type'] },
      { fields: ['status'] },
      { fields: ['sort_order'] }
    ]
  });

  Badge.associate = models => {
    // ä¸ç”¨æˆ·å¤šå¯¹å¤šå…³è”
    Badge.belongsToMany(models.User, {
      through: models.UserBadge,
      foreignKey: 'badge_id',
      otherKey: 'user_id',
      as: 'users'
    });

    // ä¸ç”¨æˆ·å¾½ç« å…³è”
    Badge.hasMany(models.UserBadge, {
      foreignKey: 'badge_id',
      as: 'userBadges'
    });
  };

  return Badge;
};
```

#### 1.2 UserBadgeæ¨¡å‹ (`server/src/models/user-badge.model.js`)

```javascript
const { v4: uuidv4 } = require('uuid');

module.exports = (sequelize, DataTypes) => {
  const UserBadge = sequelize.define('UserBadge', {
    id: {
      type: DataTypes.UUID,
      primaryKey: true,
      defaultValue: () => uuidv4(),
      allowNull: false
    },
    user_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    badge_id: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'badges',
        key: 'id'
      }
    },
    granted_at: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    granted_by: {
      type: DataTypes.UUID,
      allowNull: true,
      references: {
        model: 'users',
        key: 'id'
      },
      comment: 'æˆäºˆè€…IDï¼Œnullè¡¨ç¤ºç³»ç»Ÿè‡ªåŠ¨æˆäºˆ'
    },
    is_visible: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: true,
      comment: 'ç”¨æˆ·æ˜¯å¦é€‰æ‹©æ˜¾ç¤ºæ­¤å¾½ç« '
    },
    display_order: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 0,
      comment: 'ç”¨æˆ·è‡ªå®šä¹‰æ˜¾ç¤ºé¡ºåº'
    }
  }, {
    tableName: 'user_badges',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      { 
        fields: ['user_id', 'badge_id'], 
        unique: true,
        name: 'unique_user_badge'
      },
      { fields: ['user_id'] },
      { fields: ['badge_id'] },
      { fields: ['granted_at'] }
    ]
  });

  UserBadge.associate = models => {
    // å…³è”åˆ°ç”¨æˆ·
    UserBadge.belongsTo(models.User, {
      foreignKey: 'user_id',
      as: 'user'
    });

    // å…³è”åˆ°å¾½ç« 
    UserBadge.belongsTo(models.Badge, {
      foreignKey: 'badge_id',
      as: 'badge'
    });

    // å…³è”åˆ°æˆäºˆè€…
    UserBadge.belongsTo(models.User, {
      foreignKey: 'granted_by',
      as: 'granter'
    });
  };

  return UserBadge;
};
```

### 2. æ•°æ®è®¿é—®å±‚è®¾è®¡

#### 2.1 Badge Repository (`server/src/repositories/badge.repository.js`)

```javascript
const { Badge, UserBadge, User } = require('../models');
const { Op } = require('sequelize');
const redisClient = require('../utils/redis-client');

class BadgeRepository {
  /**
   * åˆ›å»ºå¾½ç« 
   */
  async create(badgeData) {
    const badge = await Badge.create(badgeData);
    await redisClient.del('badges:all');
    return badge;
  }

  /**
   * æ ¹æ®IDæŸ¥æ‰¾å¾½ç« 
   */
  async findById(id) {
    const cacheKey = `badge:${id}`;
    const cached = await redisClient.get(cacheKey);
    
    if (cached) {
      return typeof cached === 'string' ? JSON.parse(cached) : cached;
    }

    const badge = await Badge.findByPk(id);
    if (badge) {
      await redisClient.set(cacheKey, JSON.stringify(badge), 1800);
    }
    
    return badge;
  }

  /**
   * æ ¹æ®åç§°æŸ¥æ‰¾å¾½ç« 
   */
  async findByName(name) {
    return await Badge.findOne({
      where: { name }
    });
  }

  /**
   * è·å–æ‰€æœ‰å¾½ç« 
   */
  async findAll(options = {}) {
    const { type, status = 'active', includeUserCount = false } = options;
    
    const whereClause = { status };
    if (type) whereClause.type = type;

    let badges;
    if (includeUserCount) {
      badges = await Badge.findAll({
        where: whereClause,
        attributes: {
          include: [
            [
              sequelize.literal(`(
                SELECT COUNT(*)
                FROM user_badges
                WHERE user_badges.badge_id = Badge.id
                AND user_badges.deleted_at IS NULL
              )`),
              'user_count'
            ]
          ]
        },
        order: [['sort_order', 'ASC'], ['created_at', 'DESC']]
      });
    } else {
      badges = await Badge.findAll({
        where: whereClause,
        order: [['sort_order', 'ASC'], ['created_at', 'DESC']]
      });
    }

    return badges;
  }

  /**
   * æ›´æ–°å¾½ç« 
   */
  async update(id, badgeData) {
    const badge = await Badge.findByPk(id);
    if (!badge) return null;

    await badge.update(badgeData);
    
    // æ¸…é™¤ç¼“å­˜
    await redisClient.del(`badge:${id}`);
    await redisClient.del('badges:all');
    
    return badge;
  }

  /**
   * åˆ é™¤å¾½ç« 
   */
  async delete(id) {
    // æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·ä½¿ç”¨æ­¤å¾½ç« 
    const userCount = await UserBadge.count({ where: { badge_id: id } });
    if (userCount > 0) {
      throw new Error('æ­¤å¾½ç« å·²è¢«ç”¨æˆ·ä½¿ç”¨ï¼Œæ— æ³•åˆ é™¤');
    }

    const result = await Badge.destroy({ where: { id } });
    
    if (result > 0) {
      await redisClient.del(`badge:${id}`);
      await redisClient.del('badges:all');
    }
    
    return result > 0;
  }

  /**
   * æœç´¢å¾½ç« 
   */
  async search(keyword, options = {}) {
    const { type, status = 'active' } = options;
    
    const whereClause = {
      [Op.and]: [
        { status },
        {
          [Op.or]: [
            { name: { [Op.like]: `%${keyword}%` } },
            { description: { [Op.like]: `%${keyword}%` } }
          ]
        }
      ]
    };
    
    if (type) whereClause[Op.and].push({ type });

    return await Badge.findAll({
      where: whereClause,
      order: [['sort_order', 'ASC']]
    });
  }
}

module.exports = new BadgeRepository();
```

#### 2.2 UserBadge Repository (`server/src/repositories/user-badge.repository.js`)

```javascript
const { UserBadge, Badge, User } = require('../models');
const { Op } = require('sequelize');
const redisClient = require('../utils/redis-client');

class UserBadgeRepository {
  /**
   * æˆäºˆç”¨æˆ·å¾½ç« 
   */
  async grantBadge(userId, badgeId, grantedBy = null) {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await UserBadge.findOne({
      where: { user_id: userId, badge_id: badgeId }
    });

    if (existing) {
      throw new Error('ç”¨æˆ·å·²æ‹¥æœ‰è¯¥å¾½ç« ');
    }

    const userBadge = await UserBadge.create({
      user_id: userId,
      badge_id: badgeId,
      granted_by: grantedBy
    });

    // æ¸…é™¤ç”¨æˆ·å¾½ç« ç¼“å­˜
    await redisClient.del(`user:${userId}:badges`);
    
    return userBadge;
  }

  /**
   * æ’¤é”€ç”¨æˆ·å¾½ç« 
   */
  async revokeBadge(userId, badgeId) {
    const result = await UserBadge.destroy({
      where: { user_id: userId, badge_id: badgeId }
    });

    if (result > 0) {
      await redisClient.del(`user:${userId}:badges`);
    }

    return result > 0;
  }

  /**
   * è·å–ç”¨æˆ·å¾½ç« åˆ—è¡¨
   */
  async getUserBadges(userId, options = {}) {
    const { includeHidden = false, type } = options;
    
    const cacheKey = `user:${userId}:badges:${includeHidden ? 'all' : 'visible'}${type ? `:${type}` : ''}`;
    const cached = await redisClient.get(cacheKey);
    
    if (cached) {
      return typeof cached === 'string' ? JSON.parse(cached) : cached;
    }

    const whereClause = { user_id: userId };
    if (!includeHidden) {
      whereClause.is_visible = true;
    }

    const badgeWhere = { status: 'active' };
    if (type) {
      badgeWhere.type = type;
    }

    const userBadges = await UserBadge.findAll({
      where: whereClause,
      include: [{
        model: Badge,
        as: 'badge',
        where: badgeWhere
      }],
      order: [['display_order', 'ASC'], ['granted_at', 'DESC']]
    });

    // ç¼“å­˜ç»“æœ
    await redisClient.set(cacheKey, JSON.stringify(userBadges), 1800);
    
    return userBadges;
  }

  /**
   * æ›´æ–°ç”¨æˆ·å¾½ç« æ˜¾ç¤ºè®¾ç½®
   */
  async updateDisplaySettings(userId, badgeId, settings) {
    const userBadge = await UserBadge.findOne({
      where: { user_id: userId, badge_id: badgeId }
    });

    if (!userBadge) {
      throw new Error('ç”¨æˆ·å¾½ç« ä¸å­˜åœ¨');
    }

    await userBadge.update(settings);
    
    // æ¸…é™¤ç¼“å­˜
    await redisClient.del(`user:${userId}:badges`);
    
    return userBadge;
  }

  /**
   * æ‰¹é‡æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåº
   */
  async updateDisplayOrder(userId, badgeOrders) {
    const transaction = await UserBadge.sequelize.transaction();
    
    try {
      for (const { badgeId, displayOrder } of badgeOrders) {
        await UserBadge.update(
          { display_order: displayOrder },
          { 
            where: { user_id: userId, badge_id: badgeId },
            transaction 
          }
        );
      }
      
      await transaction.commit();
      
      // æ¸…é™¤ç¼“å­˜
      await redisClient.del(`user:${userId}:badges`);
      
      return true;
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
}

module.exports = new UserBadgeRepository();
```

### 3. ä¸šåŠ¡é€»è¾‘å±‚è®¾è®¡

#### 3.1 Badge Service (`server/src/services/badge.service.js`)

```javascript
const badgeRepository = require('../repositories/badge.repository');
const userBadgeRepository = require('../repositories/user-badge.repository');
const userRepository = require('../repositories/user.repository');

class BadgeService {
  /**
   * åˆ›å»ºå¾½ç« 
   */
  async createBadge(badgeData, adminId) {
    // éªŒè¯å¾½ç« åç§°å”¯ä¸€æ€§
    const existingBadge = await badgeRepository.findByName(badgeData.name);
    if (existingBadge) {
      throw new Error('å¾½ç« åç§°å·²å­˜åœ¨');
    }

    // åˆ›å»ºå¾½ç« 
    const badge = await badgeRepository.create({
      ...badgeData,
      created_by: adminId
    });

    return badge;
  }

  /**
   * è·å–å¾½ç« åˆ—è¡¨
   */
  async getBadges(options = {}) {
    return await badgeRepository.findAll(options);
  }

  /**
   * æ›´æ–°å¾½ç« 
   */
  async updateBadge(id, badgeData, adminId) {
    const badge = await badgeRepository.findById(id);
    if (!badge) {
      throw new Error('å¾½ç« ä¸å­˜åœ¨');
    }

    // å¦‚æœä¿®æ”¹åç§°ï¼Œæ£€æŸ¥å”¯ä¸€æ€§
    if (badgeData.name && badgeData.name !== badge.name) {
      const existingBadge = await badgeRepository.findByName(badgeData.name);
      if (existingBadge && existingBadge.id !== id) {
        throw new Error('å¾½ç« åç§°å·²å­˜åœ¨');
      }
    }

    return await badgeRepository.update(id, {
      ...badgeData,
      updated_by: adminId
    });
  }

  /**
   * åˆ é™¤å¾½ç« 
   */
  async deleteBadge(id) {
    return await badgeRepository.delete(id);
  }

  /**
   * æˆäºˆç”¨æˆ·å¾½ç« 
   */
  async grantUserBadge(userId, badgeId, grantedBy) {
    // éªŒè¯ç”¨æˆ·å’Œå¾½ç« å­˜åœ¨
    const user = await userRepository.findById(userId);
    if (!user) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    const badge = await badgeRepository.findById(badgeId);
    if (!badge) {
      throw new Error('å¾½ç« ä¸å­˜åœ¨');
    }

    if (badge.status !== 'active') {
      throw new Error('å¾½ç« å·²ç¦ç”¨ï¼Œæ— æ³•æˆäºˆ');
    }

    return await userBadgeRepository.grantBadge(userId, badgeId, grantedBy);
  }

  /**
   * æ’¤é”€ç”¨æˆ·å¾½ç« 
   */
  async revokeUserBadge(userId, badgeId) {
    return await userBadgeRepository.revokeBadge(userId, badgeId);
  }

  /**
   * è·å–ç”¨æˆ·å¾½ç« 
   */
  async getUserBadges(userId, options = {}) {
    return await userBadgeRepository.getUserBadges(userId, options);
  }

  /**
   * æ£€æŸ¥è‡ªåŠ¨æˆäºˆæ¡ä»¶
   */
  async checkAutoGrantConditions(userId) {
    // è·å–æ‰€æœ‰è‡ªåŠ¨æˆäºˆçš„å¾½ç« 
    const autoGrantBadges = await badgeRepository.findAll({
      auto_grant: true,
      status: 'active'
    });

    const results = [];
    
    for (const badge of autoGrantBadges) {
      try {
        const shouldGrant = await this.evaluateGrantCondition(userId, badge.grant_condition);
        
        if (shouldGrant) {
          // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²æœ‰æ­¤å¾½ç« 
          const userBadges = await userBadgeRepository.getUserBadges(userId, { includeHidden: true });
          const hasBadge = userBadges.some(ub => ub.badge_id === badge.id);
          
          if (!hasBadge) {
            await userBadgeRepository.grantBadge(userId, badge.id, null); // nullè¡¨ç¤ºç³»ç»Ÿè‡ªåŠ¨æˆäºˆ
            results.push(badge);
          }
        }
      } catch (error) {
        console.error(`æ£€æŸ¥å¾½ç«  ${badge.name} è‡ªåŠ¨æˆäºˆæ¡ä»¶å¤±è´¥:`, error);
      }
    }

    return results;
  }

  /**
   * è¯„ä¼°æˆäºˆæ¡ä»¶
   */
  async evaluateGrantCondition(userId, condition) {
    if (!condition) return false;

    // è¿™é‡Œå¯ä»¥å®ç°å¤æ‚çš„æ¡ä»¶è¯„ä¼°é€»è¾‘
    // ä¾‹å¦‚ï¼šå‘å¸–æ•°é‡ã€è·å¾—ç‚¹èµæ•°ã€æ³¨å†Œæ—¶é•¿ç­‰
    const user = await userRepository.findById(userId);
    
    // ç¤ºä¾‹æ¡ä»¶è¯„ä¼°
    if (condition.type === 'post_count' && condition.value) {
      const userPostCount = await userRepository.getUserPostCount(userId);
      return userPostCount >= condition.value;
    }
    
    if (condition.type === 'like_count' && condition.value) {
      const userLikeCount = await userRepository.getUserTotalLikes(userId);
      return userLikeCount >= condition.value;
    }

    if (condition.type === 'register_days' && condition.value) {
      const registerDays = Math.floor((Date.now() - new Date(user.created_at).getTime()) / (1000 * 60 * 60 * 24));
      return registerDays >= condition.value;
    }

    return false;
  }
}

module.exports = new BadgeService();
```

### 4. æ§åˆ¶å™¨å±‚è®¾è®¡

#### 4.1 å‰ç«¯APIæ§åˆ¶å™¨ (`server/src/controllers/badge.controller.js`)

```javascript
const badgeService = require('../services/badge.service');
const userBadgeRepository = require('../repositories/user-badge.repository');
const { StatusCodes } = require('http-status-codes');
const logger = require('../../config/logger');

class BadgeController {
  /**
   * è·å–å¾½ç« åˆ—è¡¨
   */
  async getBadges(req, res) {
    try {
      const { type, status = 'active' } = req.query;
      
      const badges = await badgeService.getBadges({ type, status });
      
      res.status(StatusCodes.OK).json({
        success: true,
        data: badges,
        message: 'è·å–å¾½ç« åˆ—è¡¨æˆåŠŸ'
      });
    } catch (error) {
      logger.error('è·å–å¾½ç« åˆ—è¡¨å¤±è´¥:', error);
      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'è·å–å¾½ç« åˆ—è¡¨å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * è·å–ç”¨æˆ·å¾½ç« 
   */
  async getUserBadges(req, res) {
    try {
      const { userId } = req.params;
      const { type, includeHidden = false } = req.query;
      
      const userBadges = await badgeService.getUserBadges(userId, { 
        type, 
        includeHidden: includeHidden === 'true' 
      });
      
      res.status(StatusCodes.OK).json({
        success: true,
        data: userBadges,
        message: 'è·å–ç”¨æˆ·å¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('è·å–ç”¨æˆ·å¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'è·å–ç”¨æˆ·å¾½ç« å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®
   */
  async updateBadgeDisplay(req, res) {
    try {
      const userId = req.user.id;
      const { badgeId } = req.params;
      const { isVisible, displayOrder } = req.body;
      
      await userBadgeRepository.updateDisplaySettings(userId, badgeId, {
        is_visible: isVisible,
        display_order: displayOrder
      });
      
      res.status(StatusCodes.OK).json({
        success: true,
        message: 'æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®æˆåŠŸ'
      });
    } catch (error) {
      logger.error('æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®å¤±è´¥:', error);
      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * æ‰¹é‡æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåº
   */
  async updateBadgesOrder(req, res) {
    try {
      const userId = req.user.id;
      const { badgeOrders } = req.body;
      
      await userBadgeRepository.updateDisplayOrder(userId, badgeOrders);
      
      res.status(StatusCodes.OK).json({
        success: true,
        message: 'æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåºæˆåŠŸ'
      });
    } catch (error) {
      logger.error('æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåºå¤±è´¥:', error);
      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåºå¤±è´¥',
        error: error.message
      });
    }
  }
}

module.exports = new BadgeController();
```

#### 4.2 ç®¡ç†åå°æ§åˆ¶å™¨ (`server/src/controllers/admin/badge.controller.js`)

```javascript
const badgeService = require('../../services/badge.service');
const { StatusCodes } = require('http-status-codes');
const logger = require('../../../config/logger');

class AdminBadgeController {
  /**
   * è·å–å¾½ç« åˆ—è¡¨ï¼ˆç®¡ç†åå°ï¼‰
   */
  async getBadgeList(req, res) {
    try {
      const { 
        page = 1, 
        limit = 20, 
        search = '', 
        type,
        status 
      } = req.query;

      let badges = await badgeService.getBadges({ 
        type, 
        status, 
        includeUserCount: true 
      });
      
      // æœç´¢è¿‡æ»¤
      if (search) {
        badges = badges.filter(badge => 
          badge.name.toLowerCase().includes(search.toLowerCase()) ||
          badge.description?.toLowerCase().includes(search.toLowerCase())
        );
      }

      // åˆ†é¡µ
      const total = badges.length;
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + parseInt(limit);
      const paginatedBadges = badges.slice(startIndex, endIndex);

      res.status(StatusCodes.OK).json({
        success: true,
        data: {
          items: paginatedBadges,
          total: total,
          page: parseInt(page),
          limit: parseInt(limit)
        }
      });
    } catch (error) {
      logger.error('è·å–å¾½ç« åˆ—è¡¨å¤±è´¥:', error);
      res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
        success: false,
        message: 'è·å–å¾½ç« åˆ—è¡¨å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * åˆ›å»ºå¾½ç« 
   */
  async createBadge(req, res) {
    try {
      const badgeData = req.body;
      const adminId = req.user.id;
      
      const badge = await badgeService.createBadge(badgeData, adminId);
      
      logger.info('ç®¡ç†å‘˜åˆ›å»ºå¾½ç« æˆåŠŸ', {
        adminId,
        badgeId: badge.id,
        badgeName: badge.name
      });

      res.status(StatusCodes.CREATED).json({
        success: true,
        data: badge,
        message: 'åˆ›å»ºå¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('åˆ›å»ºå¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'åˆ›å»ºå¾½ç« å¤±è´¥'
      });
    }
  }

  /**
   * æ›´æ–°å¾½ç« 
   */
  async updateBadge(req, res) {
    try {
      const { id } = req.params;
      const badgeData = req.body;
      const adminId = req.user.id;
      
      const badge = await badgeService.updateBadge(id, badgeData, adminId);
      
      logger.info('ç®¡ç†å‘˜æ›´æ–°å¾½ç« æˆåŠŸ', {
        adminId,
        badgeId: id,
        badgeName: badge.name
      });

      res.status(StatusCodes.OK).json({
        success: true,
        data: badge,
        message: 'æ›´æ–°å¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('æ›´æ–°å¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'æ›´æ–°å¾½ç« å¤±è´¥'
      });
    }
  }

  /**
   * åˆ é™¤å¾½ç« 
   */
  async deleteBadge(req, res) {
    try {
      const { id } = req.params;
      const adminId = req.user.id;
      
      await badgeService.deleteBadge(id);
      
      logger.info('ç®¡ç†å‘˜åˆ é™¤å¾½ç« æˆåŠŸ', {
        adminId,
        badgeId: id
      });

      res.status(StatusCodes.OK).json({
        success: true,
        message: 'åˆ é™¤å¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('åˆ é™¤å¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'åˆ é™¤å¾½ç« å¤±è´¥'
      });
    }
  }

  /**
   * æˆäºˆç”¨æˆ·å¾½ç« 
   */
  async grantUserBadge(req, res) {
    try {
      const { userId, badgeId } = req.body;
      const grantedBy = req.user.id;
      
      await badgeService.grantUserBadge(userId, badgeId, grantedBy);
      
      logger.info('ç®¡ç†å‘˜æˆäºˆç”¨æˆ·å¾½ç« æˆåŠŸ', {
        adminId: grantedBy,
        userId,
        badgeId
      });

      res.status(StatusCodes.OK).json({
        success: true,
        message: 'æˆäºˆç”¨æˆ·å¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('æˆäºˆç”¨æˆ·å¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'æˆäºˆç”¨æˆ·å¾½ç« å¤±è´¥'
      });
    }
  }

  /**
   * æ’¤é”€ç”¨æˆ·å¾½ç« 
   */
  async revokeUserBadge(req, res) {
    try {
      const { userId, badgeId } = req.body;
      const adminId = req.user.id;
      
      await badgeService.revokeUserBadge(userId, badgeId);
      
      logger.info('ç®¡ç†å‘˜æ’¤é”€ç”¨æˆ·å¾½ç« æˆåŠŸ', {
        adminId,
        userId,
        badgeId
      });

      res.status(StatusCodes.OK).json({
        success: true,
        message: 'æ’¤é”€ç”¨æˆ·å¾½ç« æˆåŠŸ'
      });
    } catch (error) {
      logger.error('æ’¤é”€ç”¨æˆ·å¾½ç« å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'æ’¤é”€ç”¨æˆ·å¾½ç« å¤±è´¥'
      });
    }
  }

  /**
   * æ‰¹é‡æ›´æ–°å¾½ç« çŠ¶æ€
   */
  async updateBadgeStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;
      const adminId = req.user.id;
      
      const badge = await badgeService.updateBadge(id, { status }, adminId);
      
      logger.info('ç®¡ç†å‘˜æ›´æ–°å¾½ç« çŠ¶æ€æˆåŠŸ', {
        adminId,
        badgeId: id,
        status
      });

      res.status(StatusCodes.OK).json({
        success: true,
        data: badge,
        message: `${status === 'active' ? 'å¯ç”¨' : 'ç¦ç”¨'}å¾½ç« æˆåŠŸ`
      });
    } catch (error) {
      logger.error('æ›´æ–°å¾½ç« çŠ¶æ€å¤±è´¥:', error);
      res.status(StatusCodes.BAD_REQUEST).json({
        success: false,
        message: error.message || 'æ›´æ–°å¾½ç« çŠ¶æ€å¤±è´¥'
      });
    }
  }
}

module.exports = new AdminBadgeController();
```

### 5. è·¯ç”±é…ç½®

#### 5.1 å‰ç«¯APIè·¯ç”± (`server/src/routes/badge.routes.js`)

```javascript
const express = require('express');
const router = express.Router();
const badgeController = require('../controllers/badge.controller');
const authMiddleware = require('../middlewares/auth.middleware');
const validationMiddleware = require('../middlewares/validation.middleware');

// è·å–å¾½ç« åˆ—è¡¨ï¼ˆå…¬å¼€ï¼‰
router.get('/', badgeController.getBadges);

// è·å–ç”¨æˆ·å¾½ç« ï¼ˆå…¬å¼€ï¼‰
router.get('/user/:userId', badgeController.getUserBadges);

// æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®ï¼ˆéœ€è¦ç™»å½•ï¼‰
router.put(
  '/display/:badgeId',
  authMiddleware.authenticate(),
  validationMiddleware.validateBadgeDisplay,
  badgeController.updateBadgeDisplay
);

// æ‰¹é‡æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåºï¼ˆéœ€è¦ç™»å½•ï¼‰
router.put(
  '/order',
  authMiddleware.authenticate(),
  validationMiddleware.validateBadgeOrder,
  badgeController.updateBadgesOrder
);

module.exports = router;
```

#### 5.2 ç®¡ç†åå°è·¯ç”± (`server/src/routes/admin/badge.routes.js`)

```javascript
const express = require('express');
const router = express.Router();
const adminBadgeController = require('../../controllers/admin/badge.controller');
const authMiddleware = require('../../middlewares/auth.middleware');
const adminMiddleware = require('../../middlewares/admin.middleware');
const validationMiddleware = require('../../middlewares/validation.middleware');

// ç®¡ç†å‘˜æƒé™ä¸­é—´ä»¶
router.use(authMiddleware.authenticate());
router.use(adminMiddleware.requireAdmin());

// è·å–å¾½ç« åˆ—è¡¨
router.get('/', adminBadgeController.getBadgeList);

// åˆ›å»ºå¾½ç« 
router.post(
  '/',
  validationMiddleware.validateBadgeCreate,
  adminBadgeController.createBadge
);

// æ›´æ–°å¾½ç« 
router.put(
  '/:id',
  validationMiddleware.validateBadgeUpdate,
  adminBadgeController.updateBadge
);

// åˆ é™¤å¾½ç« 
router.delete('/:id', adminBadgeController.deleteBadge);

// æ›´æ–°å¾½ç« çŠ¶æ€
router.put(
  '/:id/status',
  validationMiddleware.validateBadgeStatus,
  adminBadgeController.updateBadgeStatus
);

// æˆäºˆç”¨æˆ·å¾½ç« 
router.post(
  '/grant',
  validationMiddleware.validateGrantBadge,
  adminBadgeController.grantUserBadge
);

// æ’¤é”€ç”¨æˆ·å¾½ç« 
router.post(
  '/revoke',
  validationMiddleware.validateRevokeBadge,
  adminBadgeController.revokeUserBadge
);

module.exports = router;
```

### 6. æ•°æ®éªŒè¯ä¸­é—´ä»¶

#### 6.1 BadgeéªŒè¯ä¸­é—´ä»¶ (`server/src/middlewares/validation/badge.validation.js`)

```javascript
const { body, param, query } = require('express-validator');
const { handleValidationErrors } = require('./index');

const badgeValidation = {
  // åˆ›å»ºå¾½ç« éªŒè¯
  validateBadgeCreate: [
    body('name')
      .isLength({ min: 2, max: 50 })
      .withMessage('å¾½ç« åç§°é•¿åº¦å¿…é¡»åœ¨2-50ä¸ªå­—ç¬¦ä¹‹é—´')
      .trim(),
    
    body('description')
      .optional()
      .isLength({ max: 500 })
      .withMessage('å¾½ç« æè¿°ä¸èƒ½è¶…è¿‡500ä¸ªå­—ç¬¦')
      .trim(),
    
    body('color')
      .matches(/^#[0-9A-Fa-f]{6}$/)
      .withMessage('é¢œè‰²æ ¼å¼å¿…é¡»ä¸ºåå…­è¿›åˆ¶é¢œè‰²ä»£ç '),
    
    body('type')
      .isIn(['achievement', 'interest', 'system'])
      .withMessage('å¾½ç« ç±»å‹å¿…é¡»æ˜¯ï¼šachievementã€interestã€systemä¹‹ä¸€'),
    
    body('rarity')
      .optional()
      .isIn(['common', 'rare', 'epic', 'legendary'])
      .withMessage('ç¨€æœ‰åº¦å¿…é¡»æ˜¯ï¼šcommonã€rareã€epicã€legendaryä¹‹ä¸€'),
    
    body('auto_grant')
      .optional()
      .isBoolean()
      .withMessage('è‡ªåŠ¨æˆäºˆå¿…é¡»æ˜¯å¸ƒå°”å€¼'),
    
    body('sort_order')
      .optional()
      .isInt({ min: 0 })
      .withMessage('æ’åºå€¼å¿…é¡»æ˜¯éè´Ÿæ•´æ•°'),
    
    handleValidationErrors
  ],

  // æ›´æ–°å¾½ç« éªŒè¯
  validateBadgeUpdate: [
    param('id')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    body('name')
      .optional()
      .isLength({ min: 2, max: 50 })
      .withMessage('å¾½ç« åç§°é•¿åº¦å¿…é¡»åœ¨2-50ä¸ªå­—ç¬¦ä¹‹é—´')
      .trim(),
    
    body('description')
      .optional()
      .isLength({ max: 500 })
      .withMessage('å¾½ç« æè¿°ä¸èƒ½è¶…è¿‡500ä¸ªå­—ç¬¦')
      .trim(),
    
    body('color')
      .optional()
      .matches(/^#[0-9A-Fa-f]{6}$/)
      .withMessage('é¢œè‰²æ ¼å¼å¿…é¡»ä¸ºåå…­è¿›åˆ¶é¢œè‰²ä»£ç '),
    
    body('type')
      .optional()
      .isIn(['achievement', 'interest', 'system'])
      .withMessage('å¾½ç« ç±»å‹å¿…é¡»æ˜¯ï¼šachievementã€interestã€systemä¹‹ä¸€'),
    
    body('rarity')
      .optional()
      .isIn(['common', 'rare', 'epic', 'legendary'])
      .withMessage('ç¨€æœ‰åº¦å¿…é¡»æ˜¯ï¼šcommonã€rareã€epicã€legendaryä¹‹ä¸€'),
    
    body('status')
      .optional()
      .isIn(['active', 'inactive'])
      .withMessage('çŠ¶æ€å¿…é¡»æ˜¯ï¼šactiveæˆ–inactive'),
    
    handleValidationErrors
  ],

  // å¾½ç« çŠ¶æ€éªŒè¯
  validateBadgeStatus: [
    param('id')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    body('status')
      .isIn(['active', 'inactive'])
      .withMessage('çŠ¶æ€å¿…é¡»æ˜¯ï¼šactiveæˆ–inactive'),
    
    handleValidationErrors
  ],

  // æˆäºˆå¾½ç« éªŒè¯
  validateGrantBadge: [
    body('userId')
      .isUUID()
      .withMessage('ç”¨æˆ·IDæ ¼å¼é”™è¯¯'),
    
    body('badgeId')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    handleValidationErrors
  ],

  // æ’¤é”€å¾½ç« éªŒè¯
  validateRevokeBadge: [
    body('userId')
      .isUUID()
      .withMessage('ç”¨æˆ·IDæ ¼å¼é”™è¯¯'),
    
    body('badgeId')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    handleValidationErrors
  ],

  // å¾½ç« æ˜¾ç¤ºè®¾ç½®éªŒè¯
  validateBadgeDisplay: [
    param('badgeId')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    body('isVisible')
      .optional()
      .isBoolean()
      .withMessage('æ˜¾ç¤ºè®¾ç½®å¿…é¡»æ˜¯å¸ƒå°”å€¼'),
    
    body('displayOrder')
      .optional()
      .isInt({ min: 0 })
      .withMessage('æ˜¾ç¤ºé¡ºåºå¿…é¡»æ˜¯éè´Ÿæ•´æ•°'),
    
    handleValidationErrors
  ],

  // å¾½ç« é¡ºåºéªŒè¯
  validateBadgeOrder: [
    body('badgeOrders')
      .isArray({ min: 1 })
      .withMessage('å¾½ç« é¡ºåºå¿…é¡»æ˜¯æ•°ç»„'),
    
    body('badgeOrders.*.badgeId')
      .isUUID()
      .withMessage('å¾½ç« IDæ ¼å¼é”™è¯¯'),
    
    body('badgeOrders.*.displayOrder')
      .isInt({ min: 0 })
      .withMessage('æ˜¾ç¤ºé¡ºåºå¿…é¡»æ˜¯éè´Ÿæ•´æ•°'),
    
    handleValidationErrors
  ]
};

module.exports = badgeValidation;
```

### 7. æ•°æ®åº“è¿ç§»è„šæœ¬

#### 7.1 åˆ›å»ºbadgesè¡¨ (`server/migrations/YYYYMMDD-create-badges-table.js`)

```javascript
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // åˆ›å»ºbadgesè¡¨
    await queryInterface.createTable('badges', {
      id: {
        type: Sequelize.UUID,
        primaryKey: true,
        allowNull: false
      },
      name: {
        type: Sequelize.STRING(50),
        allowNull: false,
        unique: true
      },
      description: {
        type: Sequelize.TEXT,
        allowNull: true
      },
      color: {
        type: Sequelize.STRING(20),
        allowNull: false,
        defaultValue: '#4A90E2'
      },
      icon: {
        type: Sequelize.STRING(100),
        allowNull: true
      },
      type: {
        type: Sequelize.ENUM('achievement', 'interest', 'system'),
        allowNull: false,
        defaultValue: 'achievement'
      },
      rarity: {
        type: Sequelize.ENUM('common', 'rare', 'epic', 'legendary'),
        allowNull: false,
        defaultValue: 'common'
      },
      auto_grant: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: false
      },
      grant_condition: {
        type: Sequelize.JSON,
        allowNull: true
      },
      sort_order: {
        type: Sequelize.INTEGER,
        allowNull: false,
        defaultValue: 0
      },
      status: {
        type: Sequelize.ENUM('active', 'inactive'),
        allowNull: false,
        defaultValue: 'active'
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')
      },
      deleted_at: {
        type: Sequelize.DATE,
        allowNull: true
      }
    });

    // æ·»åŠ ç´¢å¼•
    await queryInterface.addIndex('badges', ['name'], { name: 'idx_badges_name' });
    await queryInterface.addIndex('badges', ['type'], { name: 'idx_badges_type' });
    await queryInterface.addIndex('badges', ['status'], { name: 'idx_badges_status' });
    await queryInterface.addIndex('badges', ['sort_order'], { name: 'idx_badges_sort_order' });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('badges');
  }
};
```

#### 7.2 åˆ›å»ºuser_badgesè¡¨ (`server/migrations/YYYYMMDD-create-user-badges-table.js`)

```javascript
'use strict';

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // åˆ›å»ºuser_badgesè¡¨
    await queryInterface.createTable('user_badges', {
      id: {
        type: Sequelize.UUID,
        primaryKey: true,
        allowNull: false
      },
      user_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'users',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      badge_id: {
        type: Sequelize.UUID,
        allowNull: false,
        references: {
          model: 'badges',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      granted_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      granted_by: {
        type: Sequelize.UUID,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      },
      is_visible: {
        type: Sequelize.BOOLEAN,
        allowNull: false,
        defaultValue: true
      },
      display_order: {
        type: Sequelize.INTEGER,
        allowNull: false,
        defaultValue: 0
      },
      created_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        type: Sequelize.DATE,
        allowNull: false,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')
      },
      deleted_at: {
        type: Sequelize.DATE,
        allowNull: true
      }
    });

    // æ·»åŠ å”¯ä¸€çº¦æŸå’Œç´¢å¼•
    await queryInterface.addIndex('user_badges', ['user_id', 'badge_id'], { 
      unique: true, 
      name: 'unique_user_badge' 
    });
    await queryInterface.addIndex('user_badges', ['user_id'], { name: 'idx_user_badges_user_id' });
    await queryInterface.addIndex('user_badges', ['badge_id'], { name: 'idx_user_badges_badge_id' });
    await queryInterface.addIndex('user_badges', ['granted_at'], { name: 'idx_user_badges_granted_at' });
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('user_badges');
  }
};
```

#### 7.3 æ’å…¥åˆå§‹å¾½ç« æ•°æ® (`server/seeds/badges-initial-data.js`)

```javascript
'use strict';
const { v4: uuidv4 } = require('uuid');

module.exports = {
  up: async (queryInterface, Sequelize) => {
    const badges = [
      {
        id: uuidv4(),
        name: 'æ ¡å›­è¾¾äºº',
        description: 'æ´»è·ƒåœ¨æ ¡å›­ç¤¾åŒºçš„ç”¨æˆ·ï¼Œç»å¸¸å‚ä¸è¯é¢˜è®¨è®ºå’Œå†…å®¹åˆ†äº«',
        color: '#FF6B35',
        icon: 'ğŸŒŸ',
        type: 'achievement',
        rarity: 'rare',
        auto_grant: true,
        grant_condition: JSON.stringify({ type: 'post_count', value: 50 }),
        sort_order: 1,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'ä¼˜è´¨åšä¸»',
        description: 'å‘å¸ƒé«˜è´¨é‡å†…å®¹ï¼Œè·å¾—ç¤¾åŒºç”¨æˆ·å¹¿æ³›è®¤å¯çš„åšä¸»',
        color: '#4ECDC4',
        icon: 'ğŸ‘‘',
        type: 'achievement',
        rarity: 'epic',
        auto_grant: true,
        grant_condition: JSON.stringify({ type: 'like_count', value: 500 }),
        sort_order: 2,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'è¯é¢˜ä¸“å®¶',
        description: 'åœ¨ç‰¹å®šè¯é¢˜é¢†åŸŸè¡¨ç°çªå‡ºï¼Œå…·æœ‰ä¸“ä¸šçŸ¥è¯†å’Œè§è§£',
        color: '#45B7D1',
        icon: 'ğŸ“',
        type: 'achievement',
        rarity: 'rare',
        auto_grant: false,
        grant_condition: null,
        sort_order: 3,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'æ–°æ‰‹ä¸Šè·¯',
        description: 'åˆšåŠ å…¥æ ¡å›­ç¤¾åŒºçš„ç”¨æˆ·ï¼Œæ¬¢è¿æ¥åˆ°æˆ‘ä»¬çš„å¤§å®¶åº­',
        color: '#96CEB4',
        icon: 'ğŸŒ±',
        type: 'achievement',
        rarity: 'common',
        auto_grant: true,
        grant_condition: JSON.stringify({ type: 'register_days', value: 1 }),
        sort_order: 10,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'æœˆåº¦ä¹‹æ˜Ÿ',
        description: 'å½“æœˆæœ€æ´»è·ƒã€æœ€å—æ¬¢è¿çš„ç”¨æˆ·',
        color: '#FFEAA7',
        icon: 'ğŸ†',
        type: 'achievement',
        rarity: 'legendary',
        auto_grant: false,
        grant_condition: null,
        sort_order: 5,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'å­¦ä¹ è¾¾äºº',
        description: 'çƒ­çˆ±å­¦ä¹ ï¼Œç»å¸¸åˆ†äº«å­¦ä¹ å¿ƒå¾—å’Œèµ„æº',
        color: '#6C5CE7',
        icon: 'ğŸ“š',
        type: 'interest',
        rarity: 'common',
        auto_grant: false,
        grant_condition: null,
        sort_order: 11,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'è¿åŠ¨å¥å°†',
        description: 'çƒ­çˆ±è¿åŠ¨ï¼Œç§¯æå‚ä¸å„ç§ä½“è‚²æ´»åŠ¨',
        color: '#00B894',
        icon: 'âš½',
        type: 'interest',
        rarity: 'common',
        auto_grant: false,
        grant_condition: null,
        sort_order: 12,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        id: uuidv4(),
        name: 'æ‘„å½±çˆ±å¥½è€…',
        description: 'çƒ­çˆ±æ‘„å½±ï¼Œç»å¸¸åˆ†äº«ç¾ä¸½çš„æ ¡å›­é£æ™¯',
        color: '#FD79A8',
        icon: 'ğŸ“·',
        type: 'interest',
        rarity: 'common',
        auto_grant: false,
        grant_condition: null,
        sort_order: 13,
        status: 'active',
        created_at: new Date(),
        updated_at: new Date()
      }
    ];

    await queryInterface.bulkInsert('badges', badges);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.bulkDelete('badges', null, {});
  }
};
```

### 8. å‰ç«¯é›†æˆ

#### 8.1 æ›´æ–°ç®¡ç†åå°API (`admin/src/utils/api.js`)

```javascript
// åœ¨ç°æœ‰api.jsæ–‡ä»¶ä¸­æ·»åŠ badgeç›¸å…³API
const badgeApi = {
  // è·å–å¾½ç« åˆ—è¡¨
  getList: (params) => request.get('/api/admin/badges', { params }),
  
  // åˆ›å»ºå¾½ç« 
  create: (data) => request.post('/api/admin/badges', data),
  
  // æ›´æ–°å¾½ç« 
  update: (id, data) => request.put(`/api/admin/badges/${id}`, data),
  
  // åˆ é™¤å¾½ç« 
  delete: (id) => request.delete(`/api/admin/badges/${id}`),
  
  // æ›´æ–°å¾½ç« çŠ¶æ€
  updateStatus: (id, data) => request.put(`/api/admin/badges/${id}/status`, data),
  
  // æˆäºˆç”¨æˆ·å¾½ç« 
  grantUser: (data) => request.post('/api/admin/badges/grant', data),
  
  // æ’¤é”€ç”¨æˆ·å¾½ç« 
  revokeUser: (data) => request.post('/api/admin/badges/revoke', data)
};

// å¯¼å‡ºæ—¶æ·»åŠ badge
export default {
  // ... å…¶ä»–ç°æœ‰API
  badge: badgeApi
};
```

#### 8.2 æ›´æ–°å‰ç«¯APP API (`uni-APP/src/api/badge.js`)

```javascript
// æ–°å»ºæ–‡ä»¶ï¼šuni-APP/src/api/badge.js
import request from './request';

const badgeApi = {
  /**
   * è·å–å¾½ç« åˆ—è¡¨
   */
  getBadges(params = {}) {
    return request.get('/api/badges', { params });
  },

  /**
   * è·å–ç”¨æˆ·å¾½ç« 
   */
  getUserBadges(userId, params = {}) {
    return request.get(`/api/badges/user/${userId}`, { params });
  },

  /**
   * æ›´æ–°å¾½ç« æ˜¾ç¤ºè®¾ç½®
   */
  updateBadgeDisplay(badgeId, data) {
    return request.put(`/api/badges/display/${badgeId}`, data);
  },

  /**
   * æ‰¹é‡æ›´æ–°å¾½ç« æ˜¾ç¤ºé¡ºåº
   */
  updateBadgesOrder(data) {
    return request.put('/api/badges/order', data);
  }
};

export default badgeApi;
```

#### 8.3 æ›´æ–°ä¸ªäººä¸»é¡µå¾½ç« æ˜¾ç¤º (`uni-APP/src/pages/profile/profile.vue`)

```vue
<template>
  <view class="profile-container">
    <!-- ä¸ªäººä¿¡æ¯åŒºåŸŸ -->
    <view class="profile-header">
      <!-- ç°æœ‰ç”¨æˆ·å¤´åƒå’ŒåŸºæœ¬ä¿¡æ¯ -->
      <!-- ... -->
      
      <!-- ç”¨æˆ·å¾½ç« å±•ç¤ºåŒºåŸŸ -->
      <view class="badges-section" v-if="userBadges.length > 0">
        <view class="section-header">
          <view class="section-title">
            <text class="title-icon">ğŸ†</text>
            <text class="title-text">æˆ‘çš„å¾½ç« </text>
            <text class="badge-count">({{ userBadges.length }})</text>
          </view>
          <view class="more-btn" @tap="manageBadges" v-if="isCurrentUser">
            <text class="more-text">ç®¡ç†</text>
            <text class="more-icon">></text>
          </view>
        </view>
        
        <scroll-view class="badges-scroll" scroll-x="true" show-scrollbar="false">
          <view class="badge-item" 
                v-for="userBadge in displayBadges" 
                :key="userBadge.id"
                :class="getRarityClass(userBadge.badge.rarity)"
                @tap="showBadgeDetail(userBadge.badge)">
            <view class="badge-icon" :style="{backgroundColor: userBadge.badge.color}">
              <text class="badge-icon-text">{{ userBadge.badge.icon || 'ğŸ†' }}</text>
            </view>
            <text class="badge-name">{{ userBadge.badge.name }}</text>
            <view class="rarity-indicator" :class="userBadge.badge.rarity"></view>
          </view>
        </scroll-view>
      </view>
    </view>
    
    <!-- å…¶ä»–ç°æœ‰å†…å®¹ -->
    <!-- ... -->
    
    <!-- å¾½ç« è¯¦æƒ…å¼¹çª— -->
    <uni-popup ref="badgeDetailPopup" type="center" :mask-click="true">
      <view class="badge-detail-modal">
        <view class="badge-detail-header">
          <view class="badge-large-icon" :style="{backgroundColor: selectedBadge?.color}">
            <text class="badge-large-icon-text">{{ selectedBadge?.icon || 'ğŸ†' }}</text>
          </view>
          <text class="badge-large-name">{{ selectedBadge?.name }}</text>
          <view class="badge-rarity-tag" :class="selectedBadge?.rarity">
            {{ getRarityName(selectedBadge?.rarity) }}
          </view>
        </view>
        <view class="badge-detail-content">
          <text class="badge-description">{{ selectedBadge?.description || 'æš‚æ— æè¿°' }}</text>
        </view>
        <view class="badge-detail-footer">
          <button class="close-btn" @tap="closeBadgeDetail">ç¡®å®š</button>
        </view>
      </view>
    </uni-popup>
  </view>
</template>

<script>
import badgeApi from '@/api/badge';

export default {
  data() {
    return {
      userBadges: [],
      selectedBadge: null,
      isCurrentUser: false
    };
  },
  
  computed: {
    // åªæ˜¾ç¤ºå¯è§çš„å¾½ç« ï¼ŒæŒ‰ç¨€æœ‰åº¦å’Œæ˜¾ç¤ºé¡ºåºæ’åº
    displayBadges() {
      return this.userBadges
        .filter(badge => badge.is_visible)
        .sort((a, b) => {
          // å…ˆæŒ‰ç¨€æœ‰åº¦æ’åºï¼ˆä¼ å¥‡ > å²è¯— > ç¨€æœ‰ > æ™®é€šï¼‰
          const rarityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
          const rarityDiff = rarityOrder[a.badge.rarity] - rarityOrder[b.badge.rarity];
          if (rarityDiff !== 0) return rarityDiff;
          
          // å†æŒ‰ç”¨æˆ·è‡ªå®šä¹‰é¡ºåºæ’åº
          return a.display_order - b.display_order;
        });
    }
  },
  
  async onLoad(options) {
    const { userId } = options;
    this.isCurrentUser = !userId || userId === this.getCurrentUserId();
    await this.loadUserBadges(userId || this.getCurrentUserId());
  },
  
  methods: {
    /**
     * åŠ è½½ç”¨æˆ·å¾½ç« 
     */
    async loadUserBadges(userId) {
      try {
        uni.showLoading({ title: 'åŠ è½½ä¸­...' });
        
        const response = await badgeApi.getUserBadges(userId, {
          includeHidden: this.isCurrentUser // å½“å‰ç”¨æˆ·å¯ä»¥çœ‹åˆ°éšè—çš„å¾½ç« 
        });
        
        if (response.success) {
          this.userBadges = response.data;
        }
      } catch (error) {
        console.error('åŠ è½½ç”¨æˆ·å¾½ç« å¤±è´¥:', error);
        uni.showToast({
          title: 'åŠ è½½å¾½ç« å¤±è´¥',
          icon: 'none'
        });
      } finally {
        uni.hideLoading();
      }
    },
    
    /**
     * æ˜¾ç¤ºå¾½ç« è¯¦æƒ…
     */
    showBadgeDetail(badge) {
      this.selectedBadge = badge;
      this.$refs.badgeDetailPopup.open();
    },
    
    /**
     * å…³é—­å¾½ç« è¯¦æƒ…
     */
    closeBadgeDetail() {
      this.$refs.badgeDetailPopup.close();
      this.selectedBadge = null;
    },
    
    /**
     * ç®¡ç†å¾½ç« 
     */
    manageBadges() {
      uni.navigateTo({
        url: '/pages/profile/badge-management'
      });
    },
    
    /**
     * è·å–ç¨€æœ‰åº¦æ ·å¼ç±»
     */
    getRarityClass(rarity) {
      return `rarity-${rarity}`;
    },
    
    /**
     * è·å–ç¨€æœ‰åº¦åç§°
     */
    getRarityName(rarity) {
      const names = {
        common: 'æ™®é€š',
        rare: 'ç¨€æœ‰',
        epic: 'å²è¯—',
        legendary: 'ä¼ å¥‡'
      };
      return names[rarity] || 'æœªçŸ¥';
    },
    
    /**
     * è·å–å½“å‰ç”¨æˆ·ID
     */
    getCurrentUserId() {
      // è¿™é‡Œéœ€è¦æ ¹æ®ä½ çš„ç”¨æˆ·çŠ¶æ€ç®¡ç†æ–¹å¼è·å–å½“å‰ç”¨æˆ·ID
      return this.$store.state.user.id;
    }
  }
};
</script>

<style scoped>
.badges-section {
  margin-top: 30rpx;
  padding: 0 30rpx;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20rpx;
}

.section-title {
  display: flex;
  align-items: center;
}

.title-icon {
  font-size: 28rpx;
  margin-right: 10rpx;
}

.title-text {
  font-size: 28rpx;
  font-weight: 600;
  color: #333;
}

.badge-count {
  font-size: 24rpx;
  color: #999;
  margin-left: 8rpx;
}

.more-btn {
  display: flex;
  align-items: center;
  padding: 8rpx 16rpx;
  background: #f5f5f5;
  border-radius: 20rpx;
}

.more-text {
  font-size: 24rpx;
  color: #666;
  margin-right: 4rpx;
}

.more-icon {
  font-size: 20rpx;
  color: #999;
}

.badges-scroll {
  white-space: nowrap;
  height: 140rpx;
}

.badge-item {
  display: inline-block;
  text-align: center;
  margin-right: 30rpx;
  width: 100rpx;
  position: relative;
}

.badge-icon {
  width: 60rpx;
  height: 60rpx;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto 10rpx;
  box-shadow: 0 4rpx 12rpx rgba(0,0,0,0.1);
  position: relative;
}

/* ç¨€æœ‰åº¦å‘å…‰æ•ˆæœ */
.rarity-rare .badge-icon {
  box-shadow: 0 4rpx 12rpx rgba(70, 130, 180, 0.4);
}

.rarity-epic .badge-icon {
  box-shadow: 0 4rpx 12rpx rgba(138, 43, 226, 0.4);
}

.rarity-legendary .badge-icon {
  box-shadow: 0 4rpx 12rpx rgba(255, 215, 0, 0.6);
  animation: legendary-glow 2s ease-in-out infinite alternate;
}

@keyframes legendary-glow {
  from {
    box-shadow: 0 4rpx 12rpx rgba(255, 215, 0, 0.6);
  }
  to {
    box-shadow: 0 6rpx 20rpx rgba(255, 215, 0, 0.8);
  }
}

.badge-icon-text {
  font-size: 24rpx;
  color: white;
}

.badge-name {
  font-size: 22rpx;
  color: #666;
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.rarity-indicator {
  position: absolute;
  top: -4rpx;
  right: -4rpx;
  width: 20rpx;
  height: 20rpx;
  border-radius: 50%;
  border: 2rpx solid white;
}

.rarity-indicator.common {
  background: #95a5a6;
}

.rarity-indicator.rare {
  background: #3498db;
}

.rarity-indicator.epic {
  background: #9b59b6;
}

.rarity-indicator.legendary {
  background: linear-gradient(45deg, #f1c40f, #f39c12);
  animation: legendary-pulse 1.5s ease-in-out infinite;
}

@keyframes legendary-pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
  }
}

/* å¾½ç« è¯¦æƒ…å¼¹çª—æ ·å¼ */
.badge-detail-modal {
  width: 600rpx;
  background: white;
  border-radius: 20rpx;
  padding: 40rpx;
  text-align: center;
}

.badge-detail-header {
  margin-bottom: 30rpx;
}

.badge-large-icon {
  width: 120rpx;
  height: 120rpx;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto 20rpx;
  box-shadow: 0 8rpx 24rpx rgba(0,0,0,0.15);
}

.badge-large-icon-text {
  font-size: 48rpx;
  color: white;
}

.badge-large-name {
  font-size: 36rpx;
  font-weight: 600;
  color: #333;
  display: block;
  margin-bottom: 10rpx;
}

.badge-rarity-tag {
  display: inline-block;
  padding: 6rpx 16rpx;
  border-radius: 12rpx;
  font-size: 22rpx;
  color: white;
  font-weight: 500;
}

.badge-rarity-tag.common {
  background: #95a5a6;
}

.badge-rarity-tag.rare {
  background: #3498db;
}

.badge-rarity-tag.epic {
  background: #9b59b6;
}

.badge-rarity-tag.legendary {
  background: linear-gradient(45deg, #f1c40f, #f39c12);
}

.badge-detail-content {
  margin: 30rpx 0;
}

.badge-description {
  font-size: 28rpx;
  color: #666;
  line-height: 1.6;
}

.badge-detail-footer {
  margin-top: 30rpx;
}

.close-btn {
  width: 200rpx;
  height: 70rpx;
  background: #007aff;
  color: white;
  border: none;
  border-radius: 35rpx;
  font-size: 28rpx;
}
</style>
```

### 9. è·¯ç”±é…ç½®æ›´æ–°

#### 9.1 æ›´æ–°ä¸»åº”ç”¨è·¯ç”± (`server/src/app.js`)

```javascript
// åœ¨ç°æœ‰è·¯ç”±é…ç½®ä¸­æ·»åŠ 
const badgeRoutes = require('./routes/badge.routes');

// APIè·¯ç”±é…ç½®
app.use('/api/badges', badgeRoutes);

// ç®¡ç†åå°è·¯ç”±é…ç½®
const adminBadgeRoutes = require('./routes/admin/badge.routes');
app.use('/api/admin/badges', adminBadgeRoutes);
```

#### 9.2 æ›´æ–°ç®¡ç†åå°è·¯ç”± (`admin/src/router/index.js`)

```javascript
// åœ¨ç®¡ç†åå°è·¯ç”±é…ç½®ä¸­æ·»åŠ 
{
  path: '/badge',
  name: 'Badge',
  component: () => import('@/views/badge/BadgeManagement.vue'),
  meta: {
    title: 'æ ‡ç­¾ç®¡ç†',
    icon: 'tag',
    requiresAuth: true,
    roles: ['admin']
  }
}
```

### 10. ç”¨æˆ·æ¨¡å‹å…³è”æ›´æ–°

#### 10.1 æ›´æ–°Useræ¨¡å‹ (`server/src/models/user.model.js`)

```javascript
// åœ¨User.associateæ–¹æ³•ä¸­æ·»åŠ 
User.associate = models => {
  // ... ç°æœ‰å…³è”

  // ç”¨æˆ·ä¸å¾½ç« å¤šå¯¹å¤šå…³è”
  User.belongsToMany(models.Badge, {
    through: models.UserBadge,
    foreignKey: 'user_id',
    otherKey: 'badge_id',
    as: 'badges'
  });

  // ç”¨æˆ·ä¸ç”¨æˆ·å¾½ç« å…³è”
  User.hasMany(models.UserBadge, {
    foreignKey: 'user_id',
    as: 'userBadges'
  });

  // ç”¨æˆ·ä½œä¸ºæˆäºˆè€…çš„å¾½ç« å…³è”
  User.hasMany(models.UserBadge, {
    foreignKey: 'granted_by',
    as: 'grantedBadges'
  });
};
```

#### 10.2 æ›´æ–°æ¨¡å‹ç´¢å¼•æ–‡ä»¶ (`server/src/models/index.js`)

```javascript
// ç¡®ä¿å¯¼å…¥æ–°çš„æ¨¡å‹
const Badge = require('./badge.model')(sequelize, DataTypes);
const UserBadge = require('./user-badge.model')(sequelize, DataTypes);

// æ·»åŠ åˆ°modelså¯¹è±¡
db.Badge = Badge;
db.UserBadge = UserBadge;
```

---

## ğŸ¯ å¾ªåºæ¸è¿›å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåç«¯åŸºç¡€æ¶æ„ï¼ˆé¢„ä¼°3-4å¤©ï¼‰

#### Day 1: æ•°æ®æ¨¡å‹å’Œè¿ç§»
- âœ… åˆ›å»ºBadgeå’ŒUserBadgeæ•°æ®æ¨¡å‹
- âœ… ç¼–å†™æ•°æ®åº“è¿ç§»è„šæœ¬
- âœ… åˆ›å»ºåˆå§‹å¾½ç« æ•°æ®ç§å­æ–‡ä»¶
- âœ… æ›´æ–°æ¨¡å‹å…³è”å…³ç³»

#### Day 2: æ•°æ®è®¿é—®å±‚
- âœ… å®ç°BadgeRepositoryæ•°æ®è®¿é—®å±‚
- âœ… å®ç°UserBadgeRepositoryæ•°æ®è®¿é—®å±‚
- âœ… æ·»åŠ Redisç¼“å­˜æ”¯æŒ
- âœ… ç¼–å†™Repositoryå±‚å•å…ƒæµ‹è¯•

#### Day 3: ä¸šåŠ¡é€»è¾‘å±‚
- âœ… å®ç°BadgeServiceä¸šåŠ¡é€»è¾‘
- âœ… å®ç°è‡ªåŠ¨æˆäºˆæ¡ä»¶è¯„ä¼°
- âœ… å®ç°æ¡ä»¶é…ç½®ç³»ç»Ÿ
- âœ… ç¼–å†™Serviceå±‚å•å…ƒæµ‹è¯•

#### Day 4: æ§åˆ¶å™¨å’Œè·¯ç”±
- âœ… å®ç°å‰ç«¯APIæ§åˆ¶å™¨
- âœ… å®ç°ç®¡ç†åå°æ§åˆ¶å™¨
- âœ… é…ç½®è·¯ç”±å’Œä¸­é—´ä»¶
- âœ… å®ç°æ•°æ®éªŒè¯ä¸­é—´ä»¶

### ç¬¬äºŒé˜¶æ®µï¼šç®¡ç†åå°é›†æˆï¼ˆé¢„ä¼°2å¤©ï¼‰

#### Day 5: ç®¡ç†åå°APIé›†æˆ
- âœ… æ›´æ–°ç®¡ç†åå°APIé…ç½®
- âœ… æµ‹è¯•ç°æœ‰BadgeManagement.vueç•Œé¢
- âœ… ä¿®å¤APIå¯¹æ¥é—®é¢˜
- âœ… æ·»åŠ ç”¨æˆ·å¾½ç« ç®¡ç†åŠŸèƒ½

#### Day 6: ç®¡ç†åŠŸèƒ½å®Œå–„
- âœ… å®ç°å¾½ç« æ‰¹é‡æ“ä½œ
- âœ… æ·»åŠ ç”¨æˆ·å¾½ç« æˆäºˆç•Œé¢
- âœ… å®ç°å¾½ç« ä½¿ç”¨ç»Ÿè®¡
- âœ… å®Œå–„æƒé™æ§åˆ¶

### ç¬¬ä¸‰é˜¶æ®µï¼šå‰ç«¯å±•ç¤ºé›†æˆï¼ˆé¢„ä¼°2å¤©ï¼‰

#### Day 7: å‰ç«¯APIå’Œç»„ä»¶
- âœ… åˆ›å»ºå‰ç«¯å¾½ç« APIæ¥å£
- âœ… æ›´æ–°ä¸ªäººä¸»é¡µä»¥åŠç”¨æˆ·ä¸ªäººä¸»é¡µçš„å¾½ç« æ˜¾ç¤ºä»¥åŠå®ç°å¾½ç« è¯¦æƒ…å¼¹çª—
- âœ… ç»™å¸–å­ç»„ä»¶çš„åå­—æ—è¾¹å¢åŠ ä¸€ä¸ªæ˜¾ç¤ºåŒºåŸŸç”¨æ¥æ˜¾ç¤ºå¾®ç« 
- âœ… å¯¹æ¥ä¸€ä¸‹pages/profile/editç¼–è¾‘èµ„æ–™é¡µé¢é‡Œé¢çš„æ ‡ç­¾åŠŸèƒ½æ³¨æ„æ˜¯æ ‡ç­¾åŠŸèƒ½ï¼Œä¸æ˜¯å¾®ç« åŠŸèƒ½
- âœ… ä¹Ÿåœ¨ä¸ªäººé¡µé¢å’Œç”¨æˆ·ä¸ªäººé¡µé¢å¢åŠ ä¸€ä¸ªæ ‡ç­¾æ˜¾ç¤ºåŒºåŸŸï¼Œæ”¹æˆç‚¹å‡»æ ‡ç­¾å°±å¼¹å‡ºä¸€ä¸ªçª—å£ç”¨æ¥æ˜¾ç¤ºç”¨æˆ·é€‰æ‹©çš„å…´è¶£æ ‡ç­¾ï¼Œæ³¨æ„ï¼Œå¼¹çª—ä¸æ˜¯å‡­ç©ºå‡ºæ¥ï¼Œæ˜¯æ ¹æ®æŒ‰é’®æ…¢æ…¢æ”¾å¤§çš„åŠ¨ç”»è®¾è®¡
- âœ… è®¾è®¡ç¬¦åˆå‰ç«¯çš„è®¾è®¡æ¶æ„


#### Day 8: ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- âœ… å®ç°å¾½ç« æ‹–æ‹½æ’åº
- âœ… æ·»åŠ å¾½ç« è·å¾—åŠ¨ç”»æ•ˆæœ
- âœ… é›†æˆè‡ªåŠ¨æˆäºˆé€šçŸ¥
- âœ… ä¼˜åŒ–ç§»åŠ¨ç«¯é€‚é…

### ç¬¬å››é˜¶æ®µï¼šæµ‹è¯•å’Œä¼˜åŒ–ï¼ˆé¢„ä¼°1å¤©ï¼‰

#### Day 9: å®Œæ•´æµ‹è¯•
- âœ… åŠŸèƒ½æµ‹è¯•å’ŒBugä¿®å¤
- âœ… æ€§èƒ½æµ‹è¯•å’Œç¼“å­˜éªŒè¯
- âœ… è·¨æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•
- âœ… APIæ–‡æ¡£å®Œå–„

---

## ğŸš€ æŠ€æœ¯ä¼˜åŠ¿

### ğŸ“ˆ æ¶æ„ä¼˜åŠ¿
- **åˆ†å±‚æ¸…æ™°**ï¼šä¸¥æ ¼éµå¾ªMVC + Repository + Serviceåˆ†å±‚æ¶æ„
- **ä»£ç å¤ç”¨**ï¼šRepositoryå±‚å’ŒServiceå±‚å¯è¢«å¤šä¸ªControllerå¤ç”¨
- **æ˜“äºç»´æŠ¤**ï¼šèŒè´£åˆ†ç¦»ï¼Œæ¯å±‚ä¸“æ³¨è‡ªå·±çš„èŒè´£
- **æ˜“äºæµ‹è¯•**ï¼šæ¯å±‚éƒ½å¯ä»¥ç‹¬ç«‹è¿›è¡Œå•å…ƒæµ‹è¯•

### âš¡ æ€§èƒ½ä¼˜åŠ¿
- **Redisç¼“å­˜**ï¼šçƒ­ç‚¹æ•°æ®ç¼“å­˜ï¼Œå‡å°‘æ•°æ®åº“æŸ¥è¯¢
- **æ•°æ®åº“ä¼˜åŒ–**ï¼šåˆç†çš„ç´¢å¼•è®¾è®¡ï¼Œæ”¯æŒé«˜æ•ˆæŸ¥è¯¢
- **æ‰¹é‡æ“ä½œ**ï¼šæ”¯æŒæ‰¹é‡æˆäºˆã€æ’¤é”€å¾½ç« 
- **åˆ†é¡µåŠ è½½**ï¼šå¤§æ•°æ®é‡æ—¶çš„åˆ†é¡µå¤„ç†

### ğŸ”’ å®‰å…¨ä¼˜åŠ¿
- **å‚æ•°éªŒè¯**ï¼šå®Œæ•´çš„è¾“å…¥éªŒè¯å’Œè¿‡æ»¤
- **æƒé™æ§åˆ¶**ï¼šç®¡ç†å‘˜æƒé™éªŒè¯
- **SQLæ³¨å…¥é˜²æŠ¤**ï¼šä½¿ç”¨ORMé¿å…SQLæ³¨å…¥
- **XSSé˜²æŠ¤**ï¼šè¾“å‡ºæ•°æ®è½¬ä¹‰å¤„ç†

### ğŸ”§ å¯æ‰©å±•æ€§
- **çµæ´»é…ç½®**ï¼šæ”¯æŒå¤šç§å¾½ç« ç±»å‹å’Œç¨€æœ‰åº¦
- **è‡ªåŠ¨æˆäºˆ**ï¼šåŸºäºæ¡ä»¶çš„è‡ªåŠ¨å¾½ç« ç³»ç»Ÿ
- **å¤šè¯­è¨€æ”¯æŒ**ï¼šæ•°æ®ç»“æ„æ”¯æŒå›½é™…åŒ–
- **APIç‰ˆæœ¬æ§åˆ¶**ï¼šæ”¯æŒAPIç‰ˆæœ¬ç®¡ç†

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

### APIæ–‡æ¡£
- [Badge API æ¥å£æ–‡æ¡£](./docs/api/badge-api.md)
- [UserBadge API æ¥å£æ–‡æ¡£](./docs/api/user-badge-api.md)
- [ç®¡ç†åå° API æ¥å£æ–‡æ¡£](./docs/api/admin-badge-api.md)

### å¼€å‘æ–‡æ¡£
- [æ•°æ®åº“è®¾è®¡æ–‡æ¡£](./docs/database/badge-schema.md)
- [ç¼“å­˜ç­–ç•¥æ–‡æ¡£](./docs/cache/badge-cache-strategy.md)
- [æµ‹è¯•ç”¨ä¾‹æ–‡æ¡£](./docs/test/badge-test-cases.md)

### éƒ¨ç½²æ–‡æ¡£
- [ç¯å¢ƒé…ç½®è¯´æ˜](./docs/deployment/environment-setup.md)
- [æ•°æ®è¿ç§»æŒ‡å—](./docs/deployment/data-migration.md)
- [ç›‘æ§é…ç½®è¯´æ˜](./docs/deployment/monitoring-setup.md)

---

*æœ€åæ›´æ–°æ—¶é—´ï¼š2025-01-27*  
*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*ç»´æŠ¤è€…ï¼šæ ¡å›­å¢™å¼€å‘å›¢é˜Ÿ*

